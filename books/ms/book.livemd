# Linkage: Mato Grosso do Sul

## Informações Gerais

Objetivo deste book consiste em unificar as seguintes bases do estado de Mato Grosso do Sul:

* SI-PNI
* e-SUS VE
* SIVEP

As três bases são arquivos `.csv` (delimitado por `;`) e os arquivos resultantes são `.csv` (delimitado por `,`).

## Entrada

<!-- livebook:{"livebook_object":"cell_input","name":"Caminho para a base do e-SUS VE","type":"text","value":"sandbox/input/ve.csv"} -->

<!-- livebook:{"livebook_object":"cell_input","name":"Caminho para a base do SI-PNI","type":"text","value":"sandbox/input/sipni.csv"} -->

<!-- livebook:{"livebook_object":"cell_input","name":"Caminho para a base do SIVEP","type":"text","value":"sandbox/input/sivep.csv"} -->

## Saída

<!-- livebook:{"livebook_object":"cell_input","name":"Caminho para o diretório de processamento","type":"text","value":"sandbox/pipe"} -->

<!-- livebook:{"livebook_object":"cell_input","name":"Caminho para o diretório de resultados","type":"text","value":"sandbox/output"} -->

## Identificação dos caminhos

```elixir
get_input_path = fn context ->
  "Caminho para #{context}: "
  |> IO.gets()
  |> String.trim()
  |> Path.expand(__DIR__)
  |> tap(&unless(File.exists?(&1), do: raise("Caminho #{&1} não existe.")))
end

get_destination_path = fn context ->
  "Caminho para #{context}: "
  |> IO.gets()
  |> String.trim()
  |> Path.expand(__DIR__)
  |> tap(&File.mkdir_p!(&1))
end

paths = %{
  input: %{
    esus_ve: get_input_path.("a base do e-SUS VE"),
    sipni: get_input_path.("a base do SI-PNI"),
    sivep: get_input_path.("a base do SIVEP")
  },
  pipe: get_destination_path.("o diretório de processamento"),
  output: get_destination_path.("o diretório de resultados")
}
```

## Dependências

```elixir
Mix.install([:flow, :nimble_csv])

File.cwd!()
|> Path.join("utils/libs.exs")
|> Code.compile_file()

:ok
```

## 001: Normalização de CSV

* CSV por padrão deve ser separado por vírgula
* Codificação do arquivo deve ser UTF-8

```elixir
operation = &XSV.csvfy(&1, &2, ";")
suffix = "csvfy"
```

```elixir
esus_ve =
  :esus_ve
  |> Pipe.new(paths.input.esus_ve)
  |> Pipe.run(suffix, operation, result_dir: paths.pipe)
```

```elixir
sipni =
  :sipni
  |> Pipe.new(paths.input.sipni)
  |> Pipe.run(suffix, operation, result_dir: paths.pipe)
```

```elixir
sivep =
  :sivep
  |> Pipe.new(paths.input.sivep)
  |> Pipe.run(suffix, operation, result_dir: paths.pipe)
```

## 002: Corte de colunas

Colunas de interesse:

* e-SUS VE:
  * `[1] #3 dataInicioSintomas`: `DateTime`
  * `[2] #9 cpf`: `string (hash)`
  * `[3] #26 sintomas`: `string`
  * `[4] #31 resultadoTeste`: `Positivo | Negativo`
  * `[5] #47 idade`: `integer`
  * `[6] #63 municipioIBGE`: `integer (IBGE 7 dígitos)`
* SIPNI:
  * `[1] #14 paciente_cpf`: `string (hash)`
  * `[2] #19 paciente_endereco_coIbgeMunicipio`: `integer (IBGE 6 dígitos)`
  * `[3] #26 paciente_idade`: `float`
  * `[4] #37 vacina_codigo`: `integer`
  * `[5] #38 vacina_dataAplicacao`: `DateTime`
  * `[6] #45 vacina_nome`: `string`
  * `[7] #46 vacina_numDose`: `integer`
* SIVEP:
  * `[1] #4 DT_SIN_PRI`: `dd/MM/yyyy`
  * `[2] #13 NU_CPF`: `string (hash)`
  * `[3] #17 NU_IDADE_N`: `integer`
  * `[4] #32 CO_MUN_RES`: `integer (IBGE 6 dígitos)`
  * `[5] #81 HOSPITAL`: `1 | 2 | 9`
  * `[6] #82 DT_INTERNA`: `Date`
  * `[7] #127 EVOLUCAO`: `1 cura | 2 óbito | 9`
  * `[8] #128 DT_EVOLUCA`: `dd/MM/yyyy`
  * `[9] #140 PCR_SARS2`: `1 | 2 | 9`

```elixir
operation = fn columns_indexes ->
  &XSV.select(&1, &2, columns_indexes)
end

suffix = "filter_columns"
```

```elixir
indexes = [3, 9, 26, 31, 47, 63]
esus_ve = Pipe.run(esus_ve, suffix, operation.(indexes))
```

```elixir
indexes = [14, 19, 26, 37, 38, 45, 46]
sipni = Pipe.run(sipni, suffix, operation.(indexes))
```

```elixir
indexes = [4, 13, 17, 32, 81, 82, 127, 128, 140]
sivep = Pipe.run(sivep, suffix, operation.(indexes))
```

## 003: Filtro por ano

Restrições:

* e-SUS VE:
  * `[1] #3 dataInicioSintomas`: `DateTime`
    * `year == 2021`
* SIPNI:
  * `[5] #38 vacina_dataAplicacao`: `DateTime`
    * `year == 2021`
* SIVEP:
  * `[1] #4 DT_SIN_PRI`: `dd/MM/yyyy`
    * `year == 2021`
  * `[6] #82 DT_INTERNA`: `date`
    * `year == 2021`
  * `[8] #128 DT_EVOLUCA`: `dd/MM/yyyy`
    * `year == 2021`

```elixir
operation = fn columns_indexes, type ->
  regex =
    case type do
      :date -> "^2021"
      :datetime -> "^2021"
      :dd_mm_yyyy -> "2021$"
    end

  &XSV.search(&1, &2, columns_indexes, regex)
end

suffix = "filter_year"
```

```elixir
esus_ve = Pipe.run(esus_ve, suffix, operation.(1, :datetime))
```

```elixir
sipni = Pipe.run(sipni, suffix, operation.(5, :datetime))
```

```elixir
sivep =
  Pipe.run_many(sivep, suffix, [
    operation.(1, :dd_mm_yyyy),
    operation.(6, :date),
    operation.(8, :dd_mm_yyyy)
  ])
```

## 004: Filtro por idade

Restrições:

* e-SUS VE:
  * `[5] #47 idade`: `integer`
    * `> 18`
* SIPNI:
  * `[3] #26 paciente_idade`: `float`
    * `> 18`
* SIVEP:
  * `[3] #17 NU_IDADE_N`: `integer`
    * `> 18`

```elixir
operation = fn column_index, type ->
  regex =
    case type do
      :float -> "^1[8-9](.0)?|1[0-3][0-9](.0)?|[2-9][0-9](.0)?$"
      :integer -> "^1[8-9]|1[0-3][0-9]|[2-9][0-9]$"
    end

  &XSV.search(&1, &2, column_index, regex)
end

suffix = "filter_age"
```

```elixir
esus_ve = Pipe.run(esus_ve, suffix, operation.(5, :integer))
```

```elixir
sipni = Pipe.run(sipni, suffix, operation.(3, :float))
```

```elixir
sivep = Pipe.run(sivep, suffix, operation.(3, :integer))
```

## 005: Filtro por município do estado

Restringir para residentes do Mato Grosso do Sul

Restrições:

* e-SUS VE:
  * `[6] #63 municipioIBGE`: `integer (IBGE 7 dígitos)`
    * `50XXXXX`
* SIPNI:
  * `[2] #19 paciente_endereco_coIbgeMunicipio`: `integer (IBGE 6 dígitos)`
    * `50XXXX`
* SIVEP:
  * `[4] #32 CO_MUN_RES`: `integer (IBGE 6 dígitos)`
    * `50XXXX`

```elixir
operation = fn column_index ->
  &XSV.search(&1, &2, column_index, "^50")
end

suffix = "filter_state"
```

```elixir
esus_ve = Pipe.run(esus_ve, suffix, operation.(6))
```

```elixir
sipni = Pipe.run(sipni, suffix, operation.(2))
```

```elixir
sivep = Pipe.run(sivep, suffix, operation.(4))
```

## 006: Filtro de valores nulos

```elixir
operation = fn column_index ->
  &XSV.search(&1, &2, column_index, "^.+")
end

suffix = "filter_null"
```

```elixir
esus_ve =
  Pipe.run_many(esus_ve, suffix, [
    operation.(1),
    operation.(2),
    operation.(3),
    &XSV.search(&1, &2, 4, "^P"),
    operation.(5),
    operation.(6)
  ])
```

```elixir
sipni =
  Pipe.run_many(sipni, suffix, [
    operation.(1),
    operation.(2),
    operation.(3),
    operation.(4),
    operation.(5),
    operation.(6),
    operation.(7)
  ])
```

```elixir
sivep =
  Pipe.run_many(sivep, suffix, [
    operation.(1),
    operation.(2),
    operation.(3),
    operation.(4),
    operation.(5),
    operation.(6),
    operation.(7),
    operation.(8),
    operation.(9)
  ])
```

## 007: Validação e Formatação

```elixir
esus_ve =
  Pipe.run(esus_ve, "format", fn input_path, output_path ->
    input_path
    |> File.stream!(read_ahead: 100_000)
    |> NimbleCSV.RFC4180.parse_stream()
    |> Flow.from_enumerable()
    |> Flow.map(fn [date, cpf, _symptoms, _result, age, city] ->
      [
        cpf,
        FormatUtils.date(date, :datetime),
        FormatUtils.city(city),
        FormatUtils.age_index(age, :from_18_to_80_by_10)
      ]
    end)
    |> then(
      &[
        [
          "esus_cpf",
          "esus_symptoms_date",
          "esus_city",
          "esus_age_index_18_to_80_by_10"
        ]
        | Enum.to_list(&1)
      ]
    )
    |> NimbleCSV.RFC4180.dump_to_iodata()
    |> then(&File.write!(output_path, &1))
  end)
```

```elixir
try do
  :ets.new(:cities, [:set, :public, :named_table])
rescue
  _error -> :ets.delete_all_objects(:cities)
end

"sandbox/input/ms_cities.csv"
|> Path.expand(__DIR__)
|> File.read!()
|> NimbleCSV.RFC4180.parse_string()
|> Enum.map(fn [id] -> {String.slice(id, 0, 6), String.to_integer(id)} end)
|> then(&:ets.insert(:cities, &1))

:ok
```

```elixir
try do
  :ets.new(:vaccines, [:set, :public, :named_table])
rescue
  _error -> :ets.delete_all_objects(:vaccines)
end

sipni =
  Pipe.run(sipni, "format", fn input_path, output_path ->
    file = File.open!(output_path, [:append])

    IO.write(
      file,
      [
        "sipni_cpf",
        "sipni_vaccination_date",
        "sipni_city",
        "sipni_age_index_18_to_80_by_10",
        "sipni_is_full_vaccination"
      ]
      |> Enum.join(",")
    )

    input_path
    |> File.stream!(read_ahead: 100_000)
    |> NimbleCSV.RFC4180.parse_stream()
    |> Flow.from_enumerable()
    |> Flow.map(fn [cpf, city, age, v_code, date, v_name, v_dosage] ->
      v_code = String.to_integer(v_code)
      :ets.insert_new(:vaccines, {v_code, v_name})

      city =
        if city == "500000" do
          nil
        else
          FormatUtils.city(city, :cities)
        end

      is_full_vaccination =
        if v_code == 88 or v_dosage == "2" do
          1
        else
          0
        end

      [
        cpf,
        FormatUtils.date(date, :datetime),
        city,
        FormatUtils.age_index(age, :from_18_to_80_by_10, float?: true),
        is_full_vaccination
      ]
    end)
    |> Stream.chunk_every(100_000)
    |> Stream.map(&IO.write(file, NimbleCSV.RFC4180.dump_to_iodata(&1)))
    |> Stream.run()

    File.close(file)
  end)
```

```elixir
sipni =
  Pipe.run(sipni, "vaccines", fn _input_path, output_path ->
    :vaccines
    |> :ets.tab2list()
    |> Enum.map(fn {code, name} -> [code, name] end)
    |> Enum.sort(&(List.first(&1) <= List.first(&2)))
    |> then(&[~w(code name) | &1])
    |> NimbleCSV.RFC4180.dump_to_iodata()
    |> then(&File.write!(output_path, &1))
  end)
```

```elixir
try do
  :ets.delete(:vaccines)
rescue
  _error -> :ok
end
```

```elixir

```
